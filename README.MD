# Cryptography Engineering

## Quiz 3

#### Message 1

``` 
ZQQTK PQUWD PGMWD BQTXY LFQWL SHAJB UCIPV KUQEJ RBAAC LRSIZ ZCRWT LDFMT PGYXF ISOSE ASZXN PHTAY HHIIR ADDIJ LBFO
E VKUWW VFFLV TCEXG HFFXF ZVGXF BFQEI ZOSEZ UGFGF UJUGK PCZWZ UQQJI VAFLV CSDCX YOPYR SQTEI HQFII VTAYI LRGGR AWAR
N LAGWK JCZXZ UIMPC FTAVX LHMRU LAMRT PDMXV VIDWV SJQWW YCYOE VKXIU NSBVV CWAYJ SMMGH BWDIU DSYYJ AGQXR ZWP
IF SRZSK PCZWR URQQS YOOIW YSELF USEEE KOEAV SSMVE DSYYJ APQHR PZKYE SSMVE PBSWF TSFLZ UUILZ JVUXY HGOSJ AIERF ZAMP
C SONSL YOZHR ULUIK FHAET XIUVV HBPXY PGPMW MWOYC AMMXK HQTIJ PHEIC MAAVV JZAWV SMFSR UOSIZ UKTMT ODDSX YSEW
Y HGSEZ USPEJ AFARX HGOIE KSZGP VJQVG YSVYU PQQEE KWZAY PQTTV YGARJ HBPXY PBSWR YSPEP IMPEP MWZHZ UUFLV PFDIR SZQ
ZV SWZPZ LIAJK OSUVT VBHIE AWARR SJMPL LHTIJ HAQTI PBOMG SSEAY PQTLR CSEAV WHMAR FHDEU PHUSE HZMFL ZSEEE KKTMT O
ODID HYURX YOBMU OOHST HAARX AVQVV CSZYV ZCRWZ USOYI PGFWR UREXI PDBME NHTIK OWZXR DRDCM LWXJI VAMXK YOOXZ C
SEYG LFEXZ AWARJ HFQAF YYURX HGMGK PJQPP PBXMK LFMXL YSMWZ UGAGZ LHKXY LQDIU BZUXP VTARV DFUXV YCDXY LDMVK POX
MK FCREE VHTII MWZHJ HGBSN LFRYC HHAYT OGFSE LOZHR ZKTSC LGAQV HQTEJ AWEID LBFME AVQLV HZFLP ZQQTK PQUWD VTMXV
TDQVR ASOPR ZGAJR UHMKF UWEXJ HGFLV KFQED ZCRGF UGQVM HHUWD VFFLV PABSJ AIDIJ VTBPL YOXMJ AGURV JIDIJ PBFLV JVGVT
OVUWK VFKEE KHDEU PHUSE DVQXY LFAJR UQUIE ACDGF TDMVR AWHIC FFQGV UHFMD LGMVV ZINNV JHQHK VJQVP KWRJV YSZXY
HBPPZ UURVF THTEK DVUGY AVQME KIXKV UQQSI JFQHL SWFCF MTAVD LFMKV ZQAYC KOXPF DAQVV ZHMXV TSZXJ HFQNV HZAYJ SM
IEK JVQHR URFLV TCFMM LGAJK OSIVZ ASDJF YAMWZ TDAVK HBFEE PBSVV KWQRK PBFLV HBMPP ZWESW OWELZ ZHAVP HGFLV MOO
XJ OSDIT VFPWG YCNES PZUXP PGMTF DSDJL SOZHK YCGFC LGAQV ASEXR URUXZ ZPKXY PGFVF BPXIJ VAQWK HBPEI KHTEK HZMVX LD
AVK PCZSW OWEXF YWOEC LJUHV UQQMJ ZWRXV KQARJ PGFIE JMUWE VZQWJ WSDXZ UOOMF BGMRU LLMGK PBSME PHEHV TOZHJ
PBNVZ LTFSN YWFIR OWEXF YMIID BGFOE VKYSI LHTEE TSDIW HQFWY BAMRE HHGVV CWQAV KIZHV YOZME KIOXZ VBAJV EHQRU LRQ
BG LFUIE JSUWK OSNIJ AVQPG ACFLV JFUXZ JWEQF MVGQR UVUWK VFKLZ ZHAVZ JOXGY HFMGK LFEGR UCZPP ISQWK PAMXV KPKXY L
GFEE KODHN OWOLY BAMRV EDQVZ LBOIN OSFLV YOOXL HZAVK YOPMK PCZEI FVMWW BFZMJ OSPXF MCDQT VFDIT AJUIN ZCRME K
WHMU BOXWN LAGWK YSSEI KHTID HGRSI TWZKG HFFWF MOSVV HHILF SSIID BGFQV HGGVV AVQQS FHTIZ YFQPR AWARK VHTID HGE
SW ISURX ZPKAY VAFLV FODIJ BFDSL URQHR URURT VBFID WZMXZ UUFLV PBOMU LBFWZ UHTIZ YZUZV ZCDGF URUXZ VBILZ JVFVR KW
FMF UVMWY HBPIU KCIRK VIEAV TIEXI HHTII JCZWZ KSDXY LUQRV YOXFV HFURX VTFLV DVAPV UODVR AWHIK OOZXY LFQWG LQFMM
LDDSS HPUPZ AMAJZ AGPIK HWXW
```

#### Message 2

```angular2html
IVIKDKDQMJGLPWLZGMPFBJIIDBBYSLJDXFGBIWWEHAPHEYSGNCCYOOTSTZABCOBVRTAZEYWVWWAZAIDGAZ
PETHPVBPWOBVJXGFMDOBCGPFKXKSZZAIGCJRPETACJHUTHPVHKJHPZHFPMEVZEQSBYOMHSDVFTASFGZTC
OBZCGHFMDOBCWVNVBRVKRGXDBMKFBTGBVGMPTBVFMTGBLBMXZWESHGCBYSKDTBYSFWOARQHCJQEQBC
UIDCNCHWWGNEDWIHPTKQCZGDKIGDENHPZGIGWVTWIASBFHATQIJSBCDWZBMPGQKKTHTQIGMEFMJSGISLK
CFTHPVFXLSZVHAGSMGCLHWJCSXMDTRBTIWWEGHUHPVGXRZCJWHCCZZBVPFKVFTIWWECYIVQJUXCHTVAT
CWVRBHJHPFILTCNYWLUOBYSKHAIEGBDBBYSKTKIJHATSFGZTCOBZCGIVIKVXLOAZBAXRQEUYDFITFBBSWIHA
PHPVKTHAIUOGSHPRHMWSGNWLWSLKCTKCQUOGPGGCIFDFBYOMWSPRRLDAMUWLTOAVKAXQPTONHSLYWL
HSOISZPHQFBBRCCCRMWWVBCYCCWKVXGOLVENPHMJCEJHQFBLIVMJSMWSVYOWICJVGBUHMUOGSPICOGR
SLRUTXBAKSTRVWKVXG
```

### Question 1

**Determine the keyword length of these two encrypted messages using I.C.**

Use the following function to calculate the I.C. of a message:

    def count_ic(message):
        """Count the Index of Coincidence (IC) for a given message"""
        message = message.lower().replace(" ", "")
        freqs = {char: message.count(char) for char in string.ascii_lowercase}
        n = len(message)
        ic = sum([freqs[char] * (freqs[char] - 1) for char in freqs]) / (n * (n - 1))
        return ic

Then find keyword length by finding the highest I.C. value for a given key length.
You will need to input the key lengths according to given possible key length return by function.

    def find_key_lenth(message):
        """Find the key length of a message"""
        ic_list = []
        for i in range(1, 10):
            sp_message = split_message(message, i)
            average_ic = 0
            for msg in sp_message:
                average_ic += count_ic(msg)
            ic_list.append(average_ic / i)
        """print the key length and the corresponding IC"""
        possible_key_length = []
        for i in range(len(ic_list)):
            if ic_list[i] >= ic_list[max(i - 1, 0)] and ic_list[i] >= ic_list[min(i + 1, len(ic_list) - 1)] and ic_list[i] > 0.06:
                possible_key_length.append(i + 1)
            print("Key length: %d, IC: %f" % (i + 1, ic_list[i]))
        return possible_key_length

### Question 2

**Solve the encryption keyword letters**

Use the following functions to solve the keyword letters:

find_key function will find the key of a message by using find_single_key function.

find_single_key function will find the key of a message by minmalizing the distance between the frequency of the message
and the frequency of the English alphabet.

    def find_key(message, key_lenth):
        """Find the key of a message"""
        sp_message = split_message(message, key_lenth)
        key = ""
        for msg in sp_message:
            key+= find_single_key(msg)
        return key

    def find_single_key(message):
        """Find the key of a message"""
        message = message.lower()
        true_freq = [0.08167, 0.01492, 0.02782, 0.04253, 0.012702, 0.02228, 0.02015, 0.06094, 0.06966,
                0.00153, 0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987,
                0.06327, 0.09056, 0.02758, 0.00978, 0.02360, 0.00150, 0.01974, 0.00074]
        freqs = {char: message.count(char)/len(message) for char in string.ascii_lowercase}
    
        #print frequency of each letter
        # print(freqs)
    
        key = 0
        min_diff = float('inf')
        for i in range(26):
            diff = 0
            for j in range(26):
                diff += (freqs[chr((j + i) % 26 + ord('a'))] - true_freq[j])**2
            if diff < min_diff:
                min_diff = diff
                key = i
        return chr(key + ord('a'))

### Question 3

**Break this ciphertext and recover the plaintext**

decrypt function will decrypt a message with a given key we found.

    def decrypt(message, key):
        """Decrypt a message with a given key"""
        message = message.lower()
        key = key.lower()
        decrypted_message = ""
        for i in range(len(message)):
            decrypted_message += chr((ord(message[i]) - ord(key[i % len(key)])) % 26 + ord('a'))
        return decrypted_message

## Usage

run the following command to run the program:

    python 109704011.py < {YOUR_INPUT_FILE}

The code will automatically run three times.

The first time for **Part 1**, the second time for **Part 2**, and the third time for **stdin**.

At the end, **part 1** and **part 2** result will be saved in `109704011_msg1.txt` and `109704011_msg2.txt`
respectively without displaying on the screen.

**stdin** result will be displayed on the screen.

## Result

Message 1 result:

>scepticismisasmuchtheresultofknowledgeasknowledgeisofscepticismtobecontentwithwhatweatpresentknowisforthemostparttoshutourearsagainstconvictionsincefromtheverygradualcharacterofoureducationwemustcontinuallyforgetandemancipateourselvesfromknowledgepreviouslyacquiredwemustsetasideoldnotionsandembracefreshonesandaswelearnwemustbedailyunlearningsomethingwhichithascostusnosmalllabourandanxietytoacquireandthisdifficultyattachesitselfmorecloselytoanageinwhichprogresshasgainedastrongascendencyoverprejudiceandinwhichpersonsandthingsaredaybydayfindingtheirreallevelinlieuoftheirconventionalvaluethesameprincipleswhichhavesweptawaytraditionalabusesandwhicharemakingrapidhavocamongtherevenuesofsinecuristsandstrippingthethintawdryveilfromattractivesuperstitionsareworkingasactivelyinliteratureasinsocietythecredulityofonewriterorthepartialityofanotherfindsaspowerfulatouchstoneandaswholesomeachastisementinthehealthyscepticismofatemperateclassofantagonistsasthedreamsofconservatismortheimposturesofpluralistsinecuresinthechurchhistoryandtraditionwhetherofancientorcomparativelyrecenttimesaresubjectedtoverydifferenthandlingfromthatwhichtheindulgenceorcredulityofformeragescouldallowmerestatementsarejealouslywatchedandthemotivesofthewriterformasimportantaningredientintheanalysisofhishistoryasthefactsherecordsprobabilityisapowerfulandtroublesometestanditisbythistroublesomestandardthatalargeportionofhistoricalevidenceissiftedconsistencyisnolesspertinaciousandexactinginitsdemandsinbrieftowriteahistorywemustknowmorethanmerefactshumannatureviewedunderaninductionofextendedexperienceisthebesthelptothecriticismofhumanhistoryhistoricalcharacterscanonlybeestimatedbythestandardwhichhumanexperiencewhetheractualortraditionaryhasfurnishedtoformcorrectviewsofindividualswemustregardthemasformingpartsofagreatwholewemustmeasurethembytheirrelationtothemassofbeingsbywhomtheyaresurroundedandincontemplatingtheincidentsintheirlivesorconditionwhichtraditionhashandeddowntouswemustratherconsiderthegeneralbearingofthewholenarrativethantherespectiveprobabilityofitsdetails

Message 2 result:

>thatprocesssaidistartsuponthesuppositionthatwhenyouhaveeliminatedallwhichisimpossiblethenwhateverremainshoweverimprobablemustbethetruthitmaywellbethatseveralexplanationsremaininwhichcaseonetriestestaftertestuntiloneorotherofthemhasaconvincingamountofsupportwewillnowapplythisprincipletothecaseinpointasitwasfirstpresentedtometherewerethreepossibleexplanationsoftheseclusionorincarcerationofthisgentlemaninanouthouseofhisfathersmansiontherewastheexplanationthathewasinhidingforacrimeorthathewasmadandthattheywishedtoavoidanasylumorthathehadsomediseasewhichcausedhissegregationicouldthinkofnootheradequatesolutionsthesethenhadtobesiftedandbalancedagainsteachother
***

# Bonus

## Bonus 1

**Building an elementary MD5 hash cracker program via Python
Programming to recover the two hash values.**
`5f4dcc3b5aa765d61d8327deb882cf99`
`5a105e8b9d40e1329780d62ea2265d8a`

Using <a href="https://s1.nordcdn.com/nord/misc/0.55.0/nordpass/200-most-common-passwords-en.pdf">Top 200 common
password list</a>
to bulid a dictionary for md5 cracking.  
The code will iterate through the dictionary and compare the hash value with the given hash value.
If the hash value is matched, the password will be printed.

    def hack_password(password):
        print(f'[*] Cracking password: {password}...')
        for word in common_passwords:
            guess = hashlib.md5(word.encode('utf-8')).hexdigest()
            if guess.upper() == password or guess.lower() == password:
                print(f'[+] Password found: {word}')
                print('[+] Exiting...')
                print('_______________________________________________________')
                return
            else:
                print(f'[-] Guess: {word} incorrect... {guess}')
        print(f'Password not found in wordlist...')

![bonus 1](/img/bonus_1.png)

### Result

The password of `5f4dcc3b5aa765d61d8327deb882cf99` is `password`.  
The password of `5a105e8b9d40e1329780d62ea2265d8a` is `test1`.

## Bonus 2

**Perfect secrecy achieved with RSA?**

> RSA encryption is a deterministic encryption algorithm, meaning that for a given plaintext message and public key, the
> resulting ciphertext will always be the same.
>
> RSA encryption can be vulnerable to attacks if the same plaintext message is encrypted multiple times with the same
> public key. This can allow an attacker to gather information about the plaintext and potentially break the encryption.
>
> Therefore, **RSA is not a perfect secrecy system**.
>
> For perfect secrecy, one must use a system like the one-time pad, which uses a random key that is at least as long as
> the plaintext message and is used only once.


